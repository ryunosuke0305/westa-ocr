"""Application settings and configuration helpers."""

from __future__ import annotations

import os
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path
from typing import Dict, Optional
from urllib.parse import urlparse

ENV_FILE_PATH = Path("/data/.env")


@dataclass(slots=True)
class Settings:
    """Container for configuration values loaded from environment variables."""

    relay_token: str
    sqlite_path: Path
    data_dir: Path
    tmp_dir: Path
    worker_idle_sleep: float
    worker_count: int
    gemini_api_key: Optional[str]
    gemini_model: str
    webhook_timeout: float
    request_timeout: float
    log_level: str
    drive_service_account_json: Optional[Path]
    webhook_url: Optional[str]


def _unquote(value: str) -> str:
    if len(value) >= 2 and value[0] == value[-1] and value[0] in {'"', "'"}:
        inner = value[1:-1]
        if value[0] == '"':
            return bytes(inner, "utf-8").decode("unicode_escape")
        return inner
    return value


def _needs_quoting(value: str) -> bool:
    if value == "":
        return True
    special_chars = {" ", "\t", "#", "'", '"'}
    if any(char in special_chars for char in value):
        return True
    return any(separator in value for separator in ("\n", "\r"))


def _quote(value: str) -> str:
    if not _needs_quoting(value):
        return value
    escaped = (
        value.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("\n", "\\n")
        .replace("\r", "\\r")
    )
    return f'"{escaped}"'


def load_env_file(*, path: Path = ENV_FILE_PATH) -> Dict[str, str]:
    """Load key-value pairs from a ``.env`` file and update ``os.environ``."""

    if not path.exists():
        return {}

    loaded: Dict[str, str] = {}
    with path.open("r", encoding="utf-8") as handle:
        for line_number, raw_line in enumerate(handle, start=1):
            line = raw_line.strip()
            if not line or line.startswith("#"):
                continue
            if line.startswith("export "):
                line = line[len("export ") :].lstrip()
            if "=" not in line:
                raise ValueError(f"Invalid line {line_number} in {path}: missing '='")
            key, raw_value = line.split("=", 1)
            key = key.strip()
            if not key:
                raise ValueError(f"Invalid line {line_number} in {path}: empty key")
            value = _unquote(raw_value.strip())
            loaded[key] = value

    for key, value in loaded.items():
        os.environ[key] = value

    return loaded


def save_env_file(values: Dict[str, Optional[str]], *, path: Path = ENV_FILE_PATH) -> None:
    """Persist selected environment variables to a ``.env`` file."""

    path.parent.mkdir(parents=True, exist_ok=True)
    lines = ["# Autogenerated by admin dashboard\n"]
    for key in sorted(values):
        value = values[key]
        if value is None:
            continue
        lines.append(f"{key}={_quote(value)}\n")

    with path.open("w", encoding="utf-8") as handle:
        handle.writelines(lines)

def _read_float(name: str, default: float) -> float:
    raw = os.getenv(name)
    if raw is None:
        return default
    try:
        return float(raw)
    except ValueError as exc:  # pragma: no cover - defensive guard
        raise ValueError(f"Environment variable {name} must be a float, got {raw!r}") from exc


def _read_int(name: str, default: int, *, minimum: Optional[int] = None) -> int:
    raw = os.getenv(name)
    if raw is None:
        value = default
    else:
        try:
            value = int(raw)
        except ValueError as exc:  # pragma: no cover - defensive guard
            raise ValueError(f"Environment variable {name} must be an integer, got {raw!r}") from exc
    if minimum is not None and value < minimum:
        raise ValueError(f"Environment variable {name} must be >= {minimum}, got {value}")
    return value


@lru_cache(maxsize=1)
def get_settings() -> Settings:
    """Read and memoise :class:`Settings` from environment variables."""

    data_dir = Path(os.getenv("DATA_DIR", "/data")).resolve()
    sqlite_path = Path(os.getenv("SQLITE_PATH", str(data_dir / "relay.db"))).resolve()
    tmp_dir = Path(os.getenv("TMP_DIR", str(data_dir / "tmp"))).resolve()

    relay_token = os.getenv("RELAY_TOKEN")
    if not relay_token:
        raise RuntimeError("RELAY_TOKEN environment variable must be set")

    drive_service_account = os.getenv("DRIVE_SERVICE_ACCOUNT_JSON")
    drive_service_account_path = (
        Path(drive_service_account).expanduser().resolve()
        if drive_service_account
        else None
    )

    webhook_url = os.getenv("WEBHOOK_URL")
    if webhook_url:
        parsed = urlparse(webhook_url)
        if not parsed.scheme or not parsed.netloc:
            raise ValueError("WEBHOOK_URL must be an absolute URL")

    return Settings(
        relay_token=relay_token,
        sqlite_path=sqlite_path,
        data_dir=data_dir,
        tmp_dir=tmp_dir,
        worker_idle_sleep=_read_float("WORKER_IDLE_SLEEP", 1.0),
        worker_count=_read_int("WORKER_COUNT", 3, minimum=1),
        gemini_api_key=os.getenv("GEMINI_API_KEY"),
        gemini_model=os.getenv("GEMINI_MODEL", "gemini-2.5-flash"),
        webhook_timeout=_read_float("WEBHOOK_TIMEOUT", 30.0),
        request_timeout=_read_float("REQUEST_TIMEOUT", 600.0),
        log_level=os.getenv("LOG_LEVEL", "INFO"),
        drive_service_account_json=drive_service_account_path,
        webhook_url=webhook_url,
    )


__all__ = ["ENV_FILE_PATH", "Settings", "get_settings", "load_env_file", "save_env_file"]
